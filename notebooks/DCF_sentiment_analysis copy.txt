{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "d28f41ef",
   "metadata": {},
   "source": [
    "# 10Q Sentiment & DCF Analysis\n",
    "This notebook analyzes the DCF of a 10Q as well as the sentiment of the writings within the report for a given ticker and predicts its future price movement."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e514451e",
   "metadata": {},
   "source": [
    "### Imports & Config"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "9dbd2938",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os, re, sys, time, math, json, warnings, requests\n",
    "from datetime import datetime, timedelta, timezone, date\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from bs4 import BeautifulSoup\n",
    "from dotenv import load_dotenv\n",
    "from transformers import AutoTokenizer, AutoModelForSequenceClassification, TextClassificationPipeline\n",
    "\n",
    "import logging\n",
    "logging.basicConfig(\n",
    "    level=logging.INFO,\n",
    "    format=\"%(asctime)s | %(levelname)s | %(message)s\",\n",
    "    datefmt=\"%H:%M:%S\"\n",
    ")\n",
    "log = logging.getLogger(\"10Q-DCF\")\n",
    "\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "load_dotenv()\n",
    "\n",
    "SEC_EMAIL = os.getenv(\"SEC_EMAIL\")\n",
    "POLYGON_API_KEY = os.getenv(\"POLYGON_API_KEY\")\n",
    "\n",
    "TRADIER_ACCESS_TOKEN = os.getenv(\"TRADIER_ACCESS_TOKEN\")\n",
    "TRADIER_ACCOUNT_ID = os.getenv(\"TRADIER_ACCOUNT_ID\")\n",
    "TRADIER_BASE = os.getenv(\"TRADIER_BASE\")\n",
    "\n",
    "def _tradier_headers():\n",
    "    # Ensure TRADIER_ACCESS_TOKEN and TRADIER_BASE are set in .env\n",
    "    return {\n",
    "        \"Authorization\": f\"Bearer {TRADIER_ACCESS_TOKEN}\",\n",
    "        \"Accept\": \"application/json\"\n",
    "    }\n",
    "\n",
    "FINBERT_ID = \"yiyanghkust/finbert-tone\"\n",
    "SECTION_PATTERNS = [\n",
    "    (r\"item\\s+2\\.\\s*management[’']?s discussion and analysis.*?(?=item\\s+3\\.)\", \"MD&A\"),\n",
    "    (r\"item\\s+1a\\.\\s*risk factors.*?(?=item\\s+2\\.)\", \"RiskFactors\"),\n",
    "    (r\"results of operations.*?(?=liquidity|capital resources|item\\s+\\d)\", \"Results\"),\n",
    "]\n",
    "POS_PHRASES = [r\"strong demand\", r\"margin expansion\", r\"raised guidance\", r\"record (revenue|earnings)\", r\"cost (reductions|optimization)\", r\"share repurchase\", r\"cash flow (improved|growth)\"]\n",
    "NEG_PHRASES = [r\"decline in (sales|revenue)\", r\"margin compression\", r\"impairment charge\", r\"supply chain disruption\", r\"adversely affected\", r\"weaker demand\", r\"material weakness\"]\n",
    "\n",
    "def SEC_HEADERS():\n",
    "    return {\n",
    "        \"User-Agent\": f\"Severin Spagnola (contact: {SEC_EMAIL})\",\n",
    "        \"Accept-Encoding\": \"gzip, deflate\",\n",
    "    }\n",
    "\n",
    "def cap_bucket(mc):\n",
    "    if mc is None or not np.isfinite(mc): return \"unknown\"\n",
    "    mc_b = mc / 1e9\n",
    "    if mc_b < 0.3:  return \"micro\"\n",
    "    if mc_b < 2:    return \"small\"\n",
    "    if mc_b < 10:   return \"mid\"\n",
    "    if mc_b < 200:  return \"large\"\n",
    "    return \"mega\"\n",
    "\n",
    "BACKTEST_CSV = \"10q_sentiment_event_returns.csv\"\n",
    "BASELINES_JSON = \"sentiment_baselines.json\"\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7aec4208",
   "metadata": {},
   "source": [
    "### SEC + HTML Helpers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "927bff7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_cik(ticker: str) -> str:\n",
    "    url = \"https://www.sec.gov/files/company_tickers.json\"\n",
    "    js = requests.get(url, headers=SEC_HEADERS(), timeout=30).json()\n",
    "    t = ticker.upper()\n",
    "    for _, rec in js.items():\n",
    "        if rec.get(\"ticker\",\"\").upper() == t:\n",
    "            return str(rec[\"cik_str\"]).zfill(10)\n",
    "    raise ValueError(f\"CIK not found for {ticker}\")\n",
    "\n",
    "def list_10q_with_dates(cik: str, max_n=8):\n",
    "    url = f\"https://data.sec.gov/submissions/CIK{cik}.json\"\n",
    "    r = requests.get(url, headers=SEC_HEADERS(), timeout=30); r.raise_for_status()\n",
    "    rec = r.json().get(\"filings\",{}).get(\"recent\",{})\n",
    "    out = []\n",
    "    for form, acc, prim, fdate in zip(rec.get(\"form\",[]), rec.get(\"accessionNumber\",[]), rec.get(\"primaryDocument\",[]), rec.get(\"filingDate\",[])):\n",
    "        if form == \"10-Q\":\n",
    "            out.append({\"accession\": acc.replace(\"-\",\"\"), \"primary\": prim, \"filing_date\": fdate})\n",
    "        if len(out) >= max_n: break\n",
    "    return out\n",
    "\n",
    "def fetch_filing_html(cik:str, accession:str, primary:str) -> str:\n",
    "    base = f\"https://www.sec.gov/Archives/edgar/data/{int(cik)}/{accession}\"\n",
    "    url  = f\"{base}/{primary}\"\n",
    "    r = requests.get(url, headers=SEC_HEADERS(), timeout=60); r.raise_for_status()\n",
    "    return r.text\n",
    "\n",
    "def _make_soup(html: str) -> BeautifulSoup:\n",
    "    for parser in (\"lxml\", \"html5lib\", \"html.parser\"):\n",
    "        try:\n",
    "            return BeautifulSoup(html, parser)\n",
    "        except Exception:\n",
    "            pass\n",
    "    return BeautifulSoup(html, \"html.parser\")\n",
    "\n",
    "def _lower_clean(txt: str) -> str:\n",
    "    return re.sub(r\"[ \\t]+\",\" \", txt.lower())\n",
    "\n",
    "def extract_sections(html: str, patterns=SECTION_PATTERNS, fallback_full=True, cap=60000) -> dict:\n",
    "    soup = _make_soup(html)\n",
    "    txt  = soup.get_text(\"\\n\", strip=True)\n",
    "    low  = _lower_clean(txt)\n",
    "    out = {}\n",
    "    for pat, name in patterns:\n",
    "        m = re.search(pat, low, flags=re.S)\n",
    "        if m: out[name] = low[m.start():m.end()][:cap]\n",
    "    if not out and fallback_full: out[\"FullDocument\"] = low[:cap]\n",
    "    return out"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dd0f27e7",
   "metadata": {},
   "source": [
    "### FinBERT Loader + Long-Text Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "e7bdf501",
   "metadata": {},
   "outputs": [],
   "source": [
    "def load_finbert():\n",
    "    tok = AutoTokenizer.from_pretrained(FINBERT_ID)\n",
    "    mdl = AutoModelForSequenceClassification.from_pretrained(FINBERT_ID)\n",
    "    pipe = TextClassificationPipeline(model=mdl, tokenizer=tok, top_k=None, truncation=True)\n",
    "    return pipe, tok\n",
    "\n",
    "def _token_chunks(text: str, tokenizer, max_tokens=512, stride=32):\n",
    "    ids = tokenizer.encode(text, add_special_tokens=False)\n",
    "    step = max_tokens - stride\n",
    "    for i in range(0, len(ids), step):\n",
    "        window = ids[i:i+max_tokens]\n",
    "        if not window: break\n",
    "        yield tokenizer.decode(window, skip_special_tokens=True)\n",
    "\n",
    "def finbert_sent_long(text: str, pipe, tokenizer, max_tokens=512, batch=16):\n",
    "    if len(text) < 4000:\n",
    "        rows = pipe([text], truncation=True, max_length=max_tokens)\n",
    "    else:\n",
    "        chunks = list(_token_chunks(text, tokenizer, max_tokens=max_tokens))\n",
    "        rows = []\n",
    "        for i in range(0, len(chunks), batch):\n",
    "            rows.extend(pipe(chunks[i:i+batch], truncation=True, max_length=max_tokens))\n",
    "    pos = neu = neg = 0.0\n",
    "    for r in rows:\n",
    "        d = {x[\"label\"].lower(): x[\"score\"] for x in r}\n",
    "        pos += d.get(\"positive\",0.0); neu += d.get(\"neutral\",0.0); neg += d.get(\"negative\",0.0)\n",
    "    n = max(1, len(rows))\n",
    "    return {\"pos\":pos/n, \"neu\":neu/n, \"neg\":neg/n, \"sent_score\":pos/n - neg/n}\n",
    "\n",
    "def phrase_boost(text: str, pos_list=POS_PHRASES, neg_list=NEG_PHRASES, w=0.1) -> float:\n",
    "    boost = 0.0\n",
    "    for p in pos_list:\n",
    "        if re.search(p, text, flags=re.I): boost += w\n",
    "    for n in neg_list:\n",
    "        if re.search(n, text, flags=re.I): boost -= w\n",
    "    return boost\n",
    "\n",
    "def score_sections(sections: dict, pipe_tok=None) -> dict:\n",
    "    pipe, tok = pipe_tok if pipe_tok else load_finbert()\n",
    "    feats = {}\n",
    "    for name, text in sections.items():\n",
    "        fb = finbert_sent_long(text, pipe, tok, max_tokens=512, batch=16)\n",
    "        boost = phrase_boost(text)\n",
    "        feats[f\"{name}_pos\"] = fb[\"pos\"]; feats[f\"{name}_neg\"] = fb[\"neg\"]\n",
    "        base = fb.get(\"sent_score\", 0.0)\n",
    "        feats[f\"{name}_sent\"] = base + boost\n",
    "        feats[f\"{name}_boost\"] = boost\n",
    "    sents = [v for k,v in feats.items() if k.endswith(\"_sent\")]\n",
    "    feats[\"sent_overall\"] = float(np.mean(sents)) if sents else np.nan\n",
    "    return feats\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "92490187",
   "metadata": {},
   "source": [
    "### Price Data from Polygon"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "1a7a2eec",
   "metadata": {},
   "outputs": [],
   "source": [
    "def polygon_daily(ticker: str, start: str, end: str) -> pd.DataFrame:\n",
    "    url = f\"https://api.polygon.io/v2/aggs/ticker/{ticker.upper()}/range/1/day/{start}/{end}\"\n",
    "    params = {\"adjusted\":\"true\",\"sort\":\"asc\",\"limit\":50000,\"apiKey\": POLYGON_API_KEY}\n",
    "    r = requests.get(url, params=params, timeout=30); r.raise_for_status()\n",
    "    rows = r.json().get(\"results\", []) or []\n",
    "    if not rows: return pd.DataFrame(columns=[\"date\",\"close\"])\n",
    "    df = pd.DataFrame(rows)[[\"t\",\"c\"]]\n",
    "    df[\"date\"] = pd.to_datetime(df[\"t\"], unit=\"ms\", utc=True).dt.tz_convert(\"US/Eastern\").dt.date\n",
    "    return df.drop(columns=[\"t\"]).rename(columns={\"c\":\"close\"}).drop_duplicates(\"date\")\n",
    "\n",
    "def polygon_latest_close(ticker: str, lookback_days: int = 14):\n",
    "    \"\"\"Get the most recent daily close from Polygon within the last N days.\"\"\"\n",
    "    end = date.today()\n",
    "    start = end - timedelta(days=lookback_days)\n",
    "    df = polygon_daily(ticker, start.isoformat(), end.isoformat())\n",
    "    if df.empty: return None\n",
    "    return float(df.iloc[-1][\"close\"])\n",
    "\n",
    "def next_trading_close(df: pd.DataFrame, target_date: date):\n",
    "    s = df[df[\"date\"] >= target_date]\n",
    "    return None if s.empty else float(s.iloc[0][\"close\"])\n",
    "\n",
    "def event_closes(ticker: str, filing_date: str) -> dict:\n",
    "    d0 = datetime.strptime(filing_date, \"%Y-%m-%d\").date()\n",
    "    d7 = d0 + timedelta(days=7)\n",
    "    d28= d0 + timedelta(days=28)\n",
    "    start = (d0 - timedelta(days=5)).strftime(\"%Y-%m-%d\")\n",
    "    end   = (d28 + timedelta(days=5)).strftime(\"%Y-%m-%d\")\n",
    "    df = polygon_daily(ticker, start, end)\n",
    "    if df.empty: return {\"close_0\":np.nan,\"close_7\":np.nan,\"close_28\":np.nan}\n",
    "    return {\"close_0\": next_trading_close(df,d0),\n",
    "            \"close_7\": next_trading_close(df,d7),\n",
    "            \"close_28\":next_trading_close(df,d28)}\n",
    "\n",
    "# === D2) Annualized volatility from Polygon daily closes ===\n",
    "def annualized_vol_from_polygon(ticker: str, lookback_days: int = 252, winsor_pct: float = 0.0):\n",
    "    \"\"\"\n",
    "    Compute annualized volatility from daily close-to-close returns.\n",
    "    - Pulls ~1.6x lookback to survive holidays/missing days, then trims.\n",
    "    - Optional winsorization of returns to reduce single-day outlier impact.\n",
    "    Returns: float (annualized vol) or None if insufficient data.\n",
    "    \"\"\"\n",
    "    # fetch a bit more than needed to handle gaps\n",
    "    start = (date.today() - timedelta(days=int(lookback_days * 1.6))).isoformat()\n",
    "    end   = date.today().isoformat()\n",
    "    df = polygon_daily(ticker, start, end)\n",
    "    if df is None or df.empty or \"close\" not in df.columns:\n",
    "        return None\n",
    "\n",
    "    # ensure chronological order and trim to last N trading rows\n",
    "    df = df.sort_values(\"date\").tail(lookback_days + 5)  # keep a small cushion\n",
    "    px = df[\"close\"].astype(float)\n",
    "    rets = px.pct_change().dropna()\n",
    "    if rets.empty:\n",
    "        return None\n",
    "\n",
    "    # optional winsorization of returns\n",
    "    if winsor_pct and 0 < winsor_pct < 0.5:\n",
    "        lo, hi = rets.quantile(winsor_pct), rets.quantile(1 - winsor_pct)\n",
    "        rets = rets.clip(lo, hi)\n",
    "\n",
    "    daily_std = float(rets.std(ddof=0))\n",
    "    ann_vol = daily_std * (252 ** 0.5)\n",
    "    return ann_vol"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fac8e16b",
   "metadata": {},
   "source": [
    "### CSV Backtest Builder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "0cf01121",
   "metadata": {},
   "outputs": [],
   "source": [
    "def backtest_10q_sentiment(tickers, max_filings=6, sleep_sec=0.3):\n",
    "    pipe_tok = load_finbert()\n",
    "    rows = []\n",
    "    for t in tickers:\n",
    "        print(f\"[{t}] pulling 10-Qs…\")\n",
    "        cik = get_cik(t)\n",
    "        pairs = list_10q_with_dates(cik, max_n=max_filings)\n",
    "        for p in pairs:\n",
    "            try:\n",
    "                html = fetch_filing_html(cik, p[\"accession\"], p[\"primary\"])\n",
    "            except Exception as e:\n",
    "                print(f\"  skip {p['accession']} ({e})\"); continue\n",
    "            secs  = extract_sections(html)\n",
    "            feats = score_sections(secs, pipe_tok=pipe_tok)\n",
    "            px    = event_closes(t, p[\"filing_date\"])\n",
    "            row   = {\"ticker\":t,\"cik\":cik, **p, **feats, **px}\n",
    "            c0,c7,c28 = row[\"close_0\"], row[\"close_7\"], row[\"close_28\"]\n",
    "            row[\"ret_7\"]  = (c7/c0 - 1.0)*100 if c0 and c7 else np.nan\n",
    "            row[\"ret_28\"] = (c28/c0 - 1.0)*100 if c0 and c28 else np.nan\n",
    "            rows.append(row)\n",
    "            time.sleep(sleep_sec)\n",
    "    df = pd.DataFrame(rows)\n",
    "    df.to_csv(BACKTEST_CSV, index=False)\n",
    "    print(f\"Saved {BACKTEST_CSV} with {len(df)} rows.\")\n",
    "    return df\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "419f5272",
   "metadata": {},
   "source": [
    "### Backtest Analyzer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "67c51108",
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy.stats import pearsonr\n",
    "\n",
    "def run_legitimacy_checks(path=BACKTEST_CSV):\n",
    "    df = pd.read_csv(path)\n",
    "    df[\"filing_date\"] = pd.to_datetime(df[\"filing_date\"])\n",
    "    df = df.dropna(subset=[\"ret_7\",\"ret_28\"])\n",
    "    sent_cols = [c for c in df.columns if c.endswith(\"_sent\")]\n",
    "    def winsorize(s, p=0.01):\n",
    "        lo, hi = s.quantile(p), s.quantile(1-p)\n",
    "        return s.clip(lo, hi)\n",
    "    df[\"ret_7_w\"]  = winsorize(df[\"ret_7\"])\n",
    "    df[\"ret_28_w\"] = winsorize(df[\"ret_28\"])\n",
    "\n",
    "    def corr_table(y_col):\n",
    "        rows=[]\n",
    "        for c in sent_cols + ([\"sent_overall\"] if \"sent_overall\" in df.columns else []):\n",
    "            x,y = df[c], df[y_col]\n",
    "            m = x.notna() & y.notna()\n",
    "            if m.sum() < 8: rows.append((c, np.nan, np.nan)); continue\n",
    "            r,p = pearsonr(x[m], y[m])\n",
    "            rows.append((c,r,p))\n",
    "        return pd.DataFrame(rows, columns=[\"feature\",\"pearson_r\",\"p_value\"]).sort_values(\"pearson_r\", ascending=False)\n",
    "\n",
    "    corr7, corr28 = corr_table(\"ret_7_w\"), corr_table(\"ret_28_w\")\n",
    "    df = df.sort_values([\"ticker\",\"filing_date\"])\n",
    "    df[\"Δsent_overall\"] = df.groupby(\"ticker\")[\"sent_overall\"].diff()\n",
    "\n",
    "    def corr_delta(y_col):\n",
    "        rows=[]\n",
    "        x,y = df[\"Δsent_overall\"], df[y_col]\n",
    "        m = x.notna() & y.notna()\n",
    "        if m.sum() >= 8:\n",
    "            r,p = pearsonr(x[m], y[m]); rows.append((\"Δsent_overall\", r, p))\n",
    "        return pd.DataFrame(rows, columns=[\"feature\",\"pearson_r\",\"p_value\"]).sort_values(\"pearson_r\", ascending=False)\n",
    "\n",
    "    dc7, dc28 = corr_delta(\"ret_7_w\"), corr_delta(\"ret_28_w\")\n",
    "    return {\"corr7\":corr7, \"corr28\":corr28, \"dc7\":dc7, \"dc28\":dc28}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7b3eb0ac",
   "metadata": {},
   "source": [
    "### Market Cap Baselines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "b7ade05f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def polygon_market_cap(ticker: str):\n",
    "    url = f\"https://api.polygon.io/v3/reference/tickers/{ticker.upper()}\"\n",
    "    params = {\"apiKey\": POLYGON_API_KEY}\n",
    "    r = requests.get(url, params=params, timeout=20)\n",
    "    try:\n",
    "        js = r.json().get(\"results\", {})\n",
    "        return js.get(\"market_cap\", None)\n",
    "    except Exception:\n",
    "        return None\n",
    "\n",
    "def fit_bucket_baselines(path=BACKTEST_CSV, min_per_bucket=8,\n",
    "                         ret_clip_pct=0.01,             # winsorize tails of returns (1% each side)\n",
    "                         dsent_abs_cap=0.12             # hard cap on |Δsent_overall| to limit leverage\n",
    "                        ):\n",
    "    \"\"\"\n",
    "    Train per-cap baselines using robust-ish preprocessing:\n",
    "      - compute Δsent_overall per ticker\n",
    "      - attach current market cap + bucket\n",
    "      - winsorize returns within each bucket (ret_7, ret_28)\n",
    "      - cap |Δsent_overall| at dsent_abs_cap\n",
    "    Saves sentiment_baselines.json\n",
    "    \"\"\"\n",
    "    def _winsorize(series: pd.Series, p=0.01):\n",
    "        lo, hi = series.quantile(p), series.quantile(1-p)\n",
    "        return series.clip(lo, hi)\n",
    "\n",
    "    df = pd.read_csv(path)\n",
    "    df = df.dropna(subset=[\"ret_7\",\"ret_28\",\"sent_overall\"]).copy()\n",
    "    df[\"filing_date\"] = pd.to_datetime(df[\"filing_date\"])\n",
    "    df = df.sort_values([\"ticker\",\"filing_date\"])\n",
    "    df[\"Δsent_overall\"] = df.groupby(\"ticker\")[\"sent_overall\"].diff()\n",
    "\n",
    "    # attach current market cap + bucket\n",
    "    mcap = {}\n",
    "    for t in df[\"ticker\"].unique():\n",
    "        try:\n",
    "            mcap[t] = polygon_market_cap(t)\n",
    "            time.sleep(0.2)\n",
    "        except Exception:\n",
    "            mcap[t] = None\n",
    "    df[\"market_cap\"] = df[\"ticker\"].map(mcap)\n",
    "    df[\"bucket\"] = df[\"market_cap\"].map(cap_bucket)\n",
    "\n",
    "    out = {}\n",
    "    for bucket in sorted(df[\"bucket\"].dropna().unique()):\n",
    "        d = df[df[\"bucket\"] == bucket].dropna(subset=[\"Δsent_overall\",\"ret_7\",\"ret_28\"]).copy()\n",
    "        if len(d) < min_per_bucket:\n",
    "            continue\n",
    "\n",
    "        # --- winsorize per-bucket ---\n",
    "        d[\"ret_7_w\"]  = _winsorize(d[\"ret_7\"],  p=ret_clip_pct)\n",
    "        d[\"ret_28_w\"] = _winsorize(d[\"ret_28\"], p=ret_clip_pct)\n",
    "\n",
    "        # cap Δsent_overall to reduce leverage from rare huge text swings\n",
    "        d[\"Δsent_overall_c\"] = d[\"Δsent_overall\"].clip(-dsent_abs_cap, dsent_abs_cap)\n",
    "\n",
    "        # fit simple OLS: ret ~ a + b * Δsent_overall_c\n",
    "        for horizon, ycol in ((\"ret7\",\"ret_7_w\"), (\"ret28\",\"ret_28_w\")):\n",
    "            X = np.c_[np.ones(len(d)), d[\"Δsent_overall_c\"].values]\n",
    "            y = d[ycol].values\n",
    "            beta = np.linalg.pinv(X).dot(y)  # [intercept, slope]\n",
    "            intercept, slope = float(beta[0]), float(beta[1])\n",
    "            out.setdefault(bucket, {})[horizon] = {\n",
    "                \"intercept\": intercept,\n",
    "                \"slope\": slope,\n",
    "                \"n\": int(len(d)),\n",
    "                \"ret_clip_pct\": ret_clip_pct,\n",
    "                \"dsent_abs_cap\": dsent_abs_cap\n",
    "            }\n",
    "\n",
    "    with open(BASELINES_JSON,\"w\") as f:\n",
    "        json.dump(out, f, indent=2)\n",
    "    print(f\"Saved {BASELINES_JSON} (winsorized)\")\n",
    "    return out"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a9d9a81b",
   "metadata": {},
   "source": [
    "### Fundamentals + DCF Snapshot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "7ee4e413",
   "metadata": {},
   "outputs": [],
   "source": [
    "# H) FUNDAMENTALS + DCF SNAPSHOT (TTM from SEC facts)\n",
    "\n",
    "def get_company_facts(cik: str) -> dict:\n",
    "    url = f\"https://data.sec.gov/api/xbrl/companyfacts/CIK{cik}.json\"\n",
    "    r = requests.get(url, headers=SEC_HEADERS(), timeout=30); r.raise_for_status()\n",
    "    return r.json()\n",
    "\n",
    "def _ttm_sum(items, n=4):\n",
    "    if not items: return None\n",
    "    vals = [x.get(\"val\") for x in items][-n:]\n",
    "    vals = [v for v in vals if v is not None]\n",
    "    return float(np.nansum(vals)) if vals else None\n",
    "\n",
    "def build_ttm_metrics(facts: dict) -> dict:\n",
    "    usgaap = facts.get(\"facts\", {}).get(\"us-gaap\", {})\n",
    "    def get_series(tag):\n",
    "        return (usgaap.get(tag, {}).get(\"units\", {}).get(\"USD\", []) or\n",
    "                usgaap.get(tag, {}).get(\"units\", {}).get(\"USD/shares\", []) or\n",
    "                usgaap.get(tag, {}).get(\"units\", {}).get(\"shares\", []))\n",
    "    revenue_q   = get_series(\"Revenues\")\n",
    "    ni_q        = get_series(\"NetIncomeLoss\")\n",
    "    eps_q       = (usgaap.get(\"EarningsPerShareDiluted\", {}).get(\"units\", {}).get(\"USD/shares\", []) or [])\n",
    "    dil_sh_q    = get_series(\"WeightedAverageNumberOfDilutedSharesOutstanding\")\n",
    "    cfo_q       = get_series(\"NetCashProvidedByUsedInOperatingActivities\")\n",
    "    capex_q     = get_series(\"PaymentsToAcquirePropertyPlantAndEquipment\")\n",
    "\n",
    "    revenue_ttm     = _ttm_sum(revenue_q)\n",
    "    net_income_ttm  = _ttm_sum(ni_q)\n",
    "    eps_ttm         = _ttm_sum(eps_q)\n",
    "    diluted_sh_ttm  = _ttm_sum(dil_sh_q)\n",
    "    cfo_ttm         = _ttm_sum(cfo_q)\n",
    "    capex_ttm       = _ttm_sum(capex_q)\n",
    "    fcf_ttm         = (cfo_ttm or 0.0) - abs(capex_ttm or 0.0)\n",
    "\n",
    "    if eps_ttm and diluted_sh_ttm and net_income_ttm:\n",
    "        approx = eps_ttm * diluted_sh_ttm\n",
    "        if abs(approx - net_income_ttm)/max(1.0, net_income_ttm) > 0.15:\n",
    "            print(\"[warn] EPS*Shares != NetIncome by >15%. Check tags/periods.\")\n",
    "\n",
    "    return dict(\n",
    "        revenue_ttm=revenue_ttm, net_income_ttm=net_income_ttm,\n",
    "        eps_diluted_ttm=eps_ttm, diluted_shares_ttm=diluted_sh_ttm,\n",
    "        cfo_ttm=cfo_ttm, capex_ttm=capex_ttm, fcf_ttm=fcf_ttm,\n",
    "        rev_per_share=(revenue_ttm / diluted_sh_ttm) if (revenue_ttm and diluted_sh_ttm) else None,\n",
    "    )\n",
    "\n",
    "SECTOR_MULTIPLES = {\"Technology\":{\"PE\":30.0,\"PS\":6.8}, \"_default\":{\"PE\":18.0,\"PS\":2.5}}\n",
    "\n",
    "def multiples_anchor(metrics:dict, sector=\"Technology\"):\n",
    "    cfg = SECTOR_MULTIPLES.get(sector, SECTOR_MULTIPLES[\"_default\"])\n",
    "    eps = metrics.get(\"eps_diluted_ttm\")\n",
    "    rps = metrics.get(\"rev_per_share\")\n",
    "    pe_anchor = eps * cfg[\"PE\"] if eps else None\n",
    "    ps_anchor = rps * cfg[\"PS\"] if rps else None\n",
    "    anchors = [x for x in (pe_anchor, ps_anchor) if x is not None and math.isfinite(x)]\n",
    "    mid = float(np.mean(anchors)) if anchors else None\n",
    "    return {\"pe_anchor\":pe_anchor, \"ps_anchor\":ps_anchor, \"fair_value_mid\":mid, \"assumptions\":cfg}\n",
    "\n",
    "def dcf_anchor(metrics:dict, years=5, g=0.04, r=0.095, g_term=0.02):\n",
    "    fcf0 = metrics.get(\"fcf_ttm\")\n",
    "    sh   = metrics.get(\"diluted_shares_ttm\")\n",
    "    if not fcf0 or not sh or sh <= 0: return None\n",
    "    pv, fcf = 0.0, fcf0\n",
    "    for t in range(1, years+1):\n",
    "        fcf *= (1+g)\n",
    "        pv  += fcf / ((1+r)**t)\n",
    "    terminal = (fcf * (1+g_term)) / (r - g_term)\n",
    "    pv_term  = terminal / ((1+r)**years)\n",
    "    return (pv + pv_term) / sh\n",
    "\n",
    "def blended_fair_value(mult_mid, dcf_val, w=0.5):\n",
    "    if mult_mid is None and dcf_val is None: return None\n",
    "    if mult_mid is None: return dcf_val\n",
    "    if dcf_val  is None: return mult_mid\n",
    "    return w*mult_mid + (1-w)*dcf_val\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1cbc51f8",
   "metadata": {},
   "source": [
    "### Enhanced DCF Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "4c8c2bd8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Enhanced DCF Engine ===\n",
    "\n",
    "def estimate_discount_rate(ticker, base_rf=0.045, equity_risk_prem=0.055):\n",
    "    \"\"\"\n",
    "    Approximate discount rate r for DCF:\n",
    "    r = rf + beta * ERP + volatility adjustment\n",
    "    \"\"\"\n",
    "    try:\n",
    "        df = polygon_daily(ticker, (date.today() - timedelta(days=250)).isoformat(), date.today().isoformat())\n",
    "        df[\"ret\"] = df[\"close\"].pct_change()\n",
    "        vol = df[\"ret\"].std() * (252**0.5)  # annualized\n",
    "    except Exception:\n",
    "        vol = 0.25\n",
    "    beta_est = min(2.0, 0.8 + (vol / 0.25))        # simple proxy\n",
    "    r = base_rf + beta_est * equity_risk_prem\n",
    "    # small upward adjustment for very high vol\n",
    "    if vol > 0.6: r += 0.01\n",
    "    return round(r, 4)\n",
    "\n",
    "def estimate_growth_rate(ticker, delta_sent=0.0, base_g=0.04):\n",
    "    \"\"\"\n",
    "    Adjust growth rate from sentiment change and past revenue growth.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        facts = get_company_facts(get_cik(ticker))\n",
    "        usgaap = facts[\"facts\"][\"us-gaap\"]\n",
    "        rev = usgaap.get(\"Revenues\", {}).get(\"units\", {}).get(\"USD\", [])\n",
    "        vals = [x[\"val\"] for x in rev[-8:] if x.get(\"val\") is not None]\n",
    "        if len(vals) >= 4:\n",
    "            hist_g = (vals[-1]/vals[0])**(1/(len(vals)-1)) - 1\n",
    "            g = 0.5*base_g + 0.5*hist_g\n",
    "        else:\n",
    "            g = base_g\n",
    "    except Exception:\n",
    "        g = base_g\n",
    "    # slight sentiment tweak\n",
    "    g += 0.15 * delta_sent\n",
    "    return max(0.0, round(g, 4))\n",
    "\n",
    "def estimate_terminal_rate(ticker, sector=\"Technology\"):\n",
    "    \"\"\"\n",
    "    Estimate terminal growth by sector, defaulting near inflation (1–3%)\n",
    "    \"\"\"\n",
    "    sector_defaults = {\n",
    "        \"Technology\": 0.025, \"Healthcare\": 0.02, \"Consumer Staples\": 0.015,\n",
    "        \"Financials\": 0.02, \"Energy\": 0.01, \"_default\": 0.02\n",
    "    }\n",
    "    return sector_defaults.get(sector, sector_defaults[\"_default\"])\n",
    "\n",
    "def raw_dcf_ev(metrics, g, r, g_term=0.02, years=5):\n",
    "    \"\"\"\n",
    "    Compute raw enterprise value (EV) directly from free cash flow to firm (FCFF).\n",
    "    \"\"\"\n",
    "    fcf0 = metrics.get(\"fcf_ttm\")\n",
    "    if not fcf0 or not np.isfinite(fcf0): return None\n",
    "    fcf, pv = fcf0, 0.0\n",
    "    for t in range(1, years+1):\n",
    "        fcf *= (1+g)\n",
    "        pv += fcf / ((1+r)**t)\n",
    "    terminal = (fcf * (1+g_term)) / (r - g_term)\n",
    "    pv_term = terminal / ((1+r)**years)\n",
    "    ev = pv + pv_term\n",
    "    return round(ev, 2)\n",
    "\n",
    "def make_dcf_bands(metrics, g_base, r_base, g_term, vol, sens_coeff=0.25):\n",
    "    \"\"\"\n",
    "    Generate low/mid/high valuation bands based on ticker volatility and sensitivity.\n",
    "    \"\"\"\n",
    "    fcf = metrics.get(\"fcf_ttm\"); sh = metrics.get(\"diluted_shares_ttm\")\n",
    "    if not fcf or not sh: return {}\n",
    "    vol_adj = min(1.5, 1 + sens_coeff * vol)  # higher vol widens spread\n",
    "\n",
    "    scenarios = {\n",
    "        \"low\":  {\"g\": g_base * 0.5, \"r\": r_base + 0.02*vol_adj},\n",
    "        \"mid\":  {\"g\": g_base,       \"r\": r_base},\n",
    "        \"high\": {\"g\": g_base * (1+0.5*vol_adj), \"r\": max(0.01, r_base - 0.02*vol_adj)}\n",
    "    }\n",
    "\n",
    "    bands = {}\n",
    "    for name, params in scenarios.items():\n",
    "        ev = raw_dcf_ev(metrics, params[\"g\"], params[\"r\"], g_term)\n",
    "        if ev:\n",
    "            bands[name] = round(ev / sh, 2)  # per-share fair value\n",
    "    return bands"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e53034fd",
   "metadata": {},
   "source": [
    "### Options Spread Creator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1bbedc8c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def tradier_expirations(ticker: str):\n",
    "    \"\"\"\n",
    "    List available expiration dates (YYYY-MM-DD) for a symbol.\n",
    "    Be robust to empty bodies, HTML error pages (401/403), and rate limits.\n",
    "    \"\"\"\n",
    "    url = f\"{TRADIER_BASE}/markets/options/expirations\"\n",
    "    try:\n",
    "        r = requests.get(\n",
    "            url,\n",
    "            headers=_tradier_headers(),\n",
    "            params={\"symbol\": ticker.upper(), \"includeAll\": \"false\"},\n",
    "            timeout=20\n",
    "        )\n",
    "    except requests.RequestException as e:\n",
    "        print(f\"[Tradier] Network error: {e}\")\n",
    "        return []\n",
    "\n",
    "    # Handle non-200 OR empty body up front\n",
    "    if r.status_code != 200 or not r.text or not r.text.strip():\n",
    "        print(f\"[Tradier] Error {r.status_code} {r.reason}: {r.text[:200]}\")\n",
    "        return []\n",
    "\n",
    "    # Try to parse JSON safely\n",
    "    try:\n",
    "        data = r.json().get(\"expirations\", {})\n",
    "        exps = data.get(\"date\", [])\n",
    "        # API may return a single string instead of a list\n",
    "        return exps if isinstance(exps, list) else ([exps] if exps else [])\n",
    "    except Exception as e:\n",
    "        print(f\"[Tradier] JSON error (expirations) for {ticker}: {e}\")\n",
    "        print(r.text[:400])  # show first part of body for debugging (often HTML/401)\n",
    "        return []\n",
    "\n",
    "def tradier_chain(ticker: str, expiration: str):\n",
    "    url = f\"{TRADIER_BASE}/markets/options/chains\"\n",
    "    params = {\"symbol\": ticker.upper(), \"expiration\": expiration, \"greeks\": \"false\"}\n",
    "    try:\n",
    "        r = requests.get(url, headers=_tradier_headers(), params=params, timeout=20)\n",
    "    except requests.RequestException as e:\n",
    "        print(f\"[Tradier] Network error: {e}\")\n",
    "        return []\n",
    "    if r.status_code != 200 or not r.text.strip():\n",
    "        print(f\"[Tradier] Error {r.status_code} {r.reason}: {r.text[:200]}\")\n",
    "        return []\n",
    "    try:\n",
    "        js = r.json()\n",
    "        opts = js.get(\"options\", {}).get(\"option\", [])\n",
    "        return opts if isinstance(opts, list) else [opts]\n",
    "    except Exception as e:\n",
    "        print(f\"[Tradier] JSON error for {ticker}: {e}\")\n",
    "        print(r.text[:400])\n",
    "        return []\n",
    "\n",
    "def best_vertical_by_target(ticker: str, pred_pct: float, polygon_price_fn, horizon_days=28):\n",
    "    \"\"\"\n",
    "    If pred_pct > 0 => bull call vertical. If < 0 => bear put vertical.\n",
    "    'polygon_price_fn' should be a callable like polygon_latest_close(ticker)->float.\n",
    "    \"\"\"\n",
    "    # pick an expiration ~horizon_days out (nearest available)\n",
    "    today = date.today()\n",
    "    target = today + timedelta(days=horizon_days)\n",
    "    exps = tradier_expirations(ticker)\n",
    "    if not exps:\n",
    "        return None\n",
    "    # choose the expiration closest to 'target' that is >= today\n",
    "    def to_date(s): \n",
    "        y,m,d = map(int, s.split(\"-\")); \n",
    "        return date(y,m,d)\n",
    "    future_exps = [e for e in exps if to_date(e) >= today]\n",
    "    if not future_exps:\n",
    "        return None\n",
    "    exp = min(future_exps, key=lambda s: abs(to_date(s)-target))\n",
    "\n",
    "    chain = tradier_chain(ticker, exp)\n",
    "    if not chain:\n",
    "        return None\n",
    "\n",
    "    pnow = polygon_price_fn(ticker)\n",
    "    if not pnow:\n",
    "        return None\n",
    "    p_tgt = pnow * (1 + pred_pct/100.0)\n",
    "\n",
    "    # strikes universe\n",
    "    strikes = sorted({float(o[\"strike\"]) for o in chain if \"strike\" in o})\n",
    "    if not strikes:\n",
    "        return None\n",
    "    nearest = lambda x: min(strikes, key=lambda k: abs(k - x))\n",
    "\n",
    "    if pred_pct >= 0:\n",
    "        k_buy  = nearest(pnow * 0.99)\n",
    "        k_sell = nearest(p_tgt * 1.02)\n",
    "        leg_buy  = [o for o in chain if o.get(\"option_type\")==\"call\" and float(o[\"strike\"])==k_buy]\n",
    "        leg_sell = [o for o in chain if o.get(\"option_type\")==\"call\" and float(o[\"strike\"])==k_sell]\n",
    "        spread_type = \"bull_call\"\n",
    "    else:\n",
    "        k_buy  = nearest(pnow * 1.01)\n",
    "        k_sell = nearest(p_tgt * 0.98)\n",
    "        leg_buy  = [o for o in chain if o.get(\"option_type\")==\"put\" and float(o[\"strike\"])==k_buy]\n",
    "        leg_sell = [o for o in chain if o.get(\"option_type\")==\"put\" and float(o[\"strike\"])==k_sell]\n",
    "        spread_type = \"bear_put\"\n",
    "\n",
    "    if not leg_buy or not leg_sell:\n",
    "        return None\n",
    "\n",
    "    def mid(q):\n",
    "        b = float(q.get(\"bid\", 0.0)); a = float(q.get(\"ask\", 0.0))\n",
    "        return (b + a)/2 if (a and b) else float(q.get(\"last\", 0.0))\n",
    "\n",
    "    debit = max(0.01, mid(leg_buy[0]) - mid(leg_sell[0]))\n",
    "    width = abs(k_sell - k_buy)\n",
    "    max_profit = max(0.0, width - debit)\n",
    "    rr = (max_profit / debit) if debit > 0 else None\n",
    "\n",
    "    return {\n",
    "        \"type\": spread_type,\n",
    "        \"expiration\": exp,\n",
    "        \"buy_strike\": float(k_buy),\n",
    "        \"sell_strike\": float(k_sell),\n",
    "        \"debit\": round(debit, 2),\n",
    "        \"width\": float(width),\n",
    "        \"max_profit\": round(max_profit, 2),\n",
    "        \"R_by_Risk\": round(rr, 2) if rr else None,\n",
    "        \"price_now\": float(pnow),\n",
    "        \"price_target\": float(p_tgt),\n",
    "    }"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7212a63c",
   "metadata": {},
   "source": [
    "### Auto-detect Sector"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0db9264e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os, requests, re\n",
    "\n",
    "POLYGON_API_KEY = os.environ.get(\"POLYGON_API_KEY\")\n",
    "POLY_BASE = \"https://api.polygon.io\"\n",
    "\n",
    "# Minimal SIC → GICS-ish mapping by description keywords (extend as needed)\n",
    "_SIC_TO_SECTOR_MAP = [\n",
    "    (r\"(telecom|telephone|broadcast|media|stream|social)\", \"Communication Services\"),\n",
    "    (r\"(apparel|retail|hotel|restaurant|leisure|furnish|furniture|household|auto|travel|entertainment|footwear|luxury)\", \"Consumer Discretionary\"),\n",
    "    (r\"(food|beverage|supermarket|grocery|tobacco|household products)\", \"Consumer Staples\"),\n",
    "    (r\"(oil|gas|coal|energy|exploration|refinery|drilling)\", \"Energy\"),\n",
    "    (r\"(bank|insurance|broker|asset|capital markets|lending|financial)\", \"Financials\"),\n",
    "    (r\"(pharma|biotech|health|medical|hospital|diagnostic|life science|device)\", \"Health Care\"),\n",
    "    (r\"(aero|defense|machinery|transport|logistics|construction|industrial|capital goods)\", \"Industrials\"),\n",
    "    (r\"(software|semiconductor|hardware|it|information technology|computer|electronics)\", \"Information Technology\"),\n",
    "    (r\"(chem|metal|mining|paper|forest|glass|cement|commodity|materials)\", \"Materials\"),\n",
    "    (r\"(reit|real estate|property|trust)\", \"Real Estate\"),\n",
    "    (r\"(utility|electric|water|gas utility|power)\", \"Utilities\"),\n",
    "]\n",
    "\n",
    "def _map_sic_desc_to_sector(sic_desc: str) -> str:\n",
    "    if not sic_desc:\n",
    "        return \"Industrials\"  # neutral default\n",
    "    s = sic_desc.lower()\n",
    "    for pat, sector in _SIC_TO_SECTOR_MAP:\n",
    "        if re.search(pat, s):\n",
    "            return sector\n",
    "    # simple catch-alls\n",
    "    if \"furnish\" in s or \"fixture\" in s:\n",
    "        return \"Consumer Discretionary\"\n",
    "    return \"Industrials\"\n",
    "\n",
    "def detect_sector_polygon(ticker: str) -> str:\n",
    "    \"\"\"\n",
    "    Uses Polygon v3 reference/tickers/{ticker} to pull SIC description\n",
    "    and map it into the 11 GICS sectors above.\n",
    "    \"\"\"\n",
    "    url = f\"{POLY_BASE}/v3/reference/tickers/{ticker.upper()}\"\n",
    "    params = {\"apiKey\": POLYGON_API_KEY}\n",
    "    try:\n",
    "        r = requests.get(url, params=params, timeout=15)\n",
    "        if r.status_code != 200 or not r.text.strip():\n",
    "            return \"Industrials\"\n",
    "        js = r.json() or {}\n",
    "        sic_desc = js.get(\"results\", {}).get(\"sic_description\") or \"\"\n",
    "        # fallback: try NAICS description if present\n",
    "        if not sic_desc:\n",
    "            sic_desc = js.get(\"results\", {}).get(\"naics_description\", \"\")\n",
    "        return _map_sic_desc_to_sector(sic_desc)\n",
    "    except Exception:\n",
    "        return \"Industrials\"\n",
    "    \n",
    "def auto_w_short(cap_bucket: str, baselines: dict) -> float:\n",
    "    \"\"\"\n",
    "    Choose short-horizon weight from your 28d baseline quality.\n",
    "    Heuristic uses slope magnitude and sample size as a proxy for confidence.\n",
    "    Returns a value in [0.15, 0.45].\n",
    "    \"\"\"\n",
    "    b = (baselines.get(cap_bucket, {}) or {}).get(\"ret28\", {}) or {}\n",
    "    slope = abs(b.get(\"slope\", 0.0))\n",
    "    n = b.get(\"n\", 0)\n",
    "\n",
    "    # crude confidence ∈ [0,1]: steeper slopes + bigger samples → higher weight\n",
    "    conf = min(1.0, (slope * 8.0) * (n / 300.0))\n",
    "\n",
    "    return float(max(0.15, min(0.45, 0.20 + 0.25 * conf)))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "951ab4ed",
   "metadata": {},
   "source": [
    "### Single Ticker Predictor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c8176f41",
   "metadata": {},
   "outputs": [],
   "source": [
    "def latest_two_10q_delta_sent(ticker: str):\n",
    "    cik   = get_cik(ticker)\n",
    "    pairs = list_10q_with_dates(cik, max_n=2)\n",
    "    if not pairs: return np.nan, np.nan, np.nan\n",
    "    pipe_tok = load_finbert()\n",
    "    scores = []\n",
    "    for p in pairs:\n",
    "        html = fetch_filing_html(cik, p[\"accession\"], p[\"primary\"])\n",
    "        secs = extract_sections(html)\n",
    "        feats= score_sections(secs, pipe_tok=pipe_tok)\n",
    "        scores.append(feats[\"sent_overall\"])\n",
    "        time.sleep(0.3)\n",
    "    if len(scores)==1: return scores[0], np.nan, np.nan\n",
    "    return scores[0], scores[1], scores[0]-scores[1]\n",
    "\n",
    "def load_baselines(path=BASELINES_JSON):\n",
    "    if not os.path.exists(path): raise FileNotFoundError(\"Run cell G to fit/save sentiment baselines first.\")\n",
    "    with open(path,\"r\") as f:\n",
    "        return json.load(f)\n",
    "\n",
    "# === I) SINGLE-TICKER PREDICTOR — auto w_short + auto sector + raw EV DCF + bands ===\n",
    "def predict_ticker(\n",
    "    ticker: str,\n",
    "    w_short=\"auto\",                 # \"auto\" or float in [0,1]\n",
    "    sector=None,                    # None -> detect via Polygon helper\n",
    "    baselines=None,                 # pass preloaded baselines to avoid reloading\n",
    "    suggest_spread: bool = False    # keep off while debugging\n",
    "):\n",
    "    import numpy as np\n",
    "\n",
    "    # ---------- helpers (local so this cell is self-contained) ----------\n",
    "    def _load_sentiment_baselines(path: str = \"sentiment_baselines.json\") -> dict:\n",
    "        import json, os\n",
    "        try:\n",
    "            with open(path, \"r\") as f:\n",
    "                return json.load(f)\n",
    "        except Exception:\n",
    "            return {}\n",
    "\n",
    "    def _auto_w_short(cap_bucket: str, bl: dict) -> float:\n",
    "        \"\"\"\n",
    "        Choose short-horizon weight from the 28d baseline quality.\n",
    "        Heuristic uses slope magnitude and sample size as a proxy for confidence.\n",
    "        Returns a value in [0.15, 0.45].\n",
    "        \"\"\"\n",
    "        b = (bl.get(cap_bucket, {}) or {}).get(\"ret28\", {}) or {}\n",
    "        slope = abs(b.get(\"slope\", 0.0))\n",
    "        n = b.get(\"n\", 0)\n",
    "        conf = min(1.0, (slope * 8.0) * (n / 300.0))        # crude confidence\n",
    "        return float(max(0.15, min(0.45, 0.20 + 0.25 * conf)))\n",
    "\n",
    "    # resolves baselines loader name if you also have load_baselines() elsewhere\n",
    "    def _get_all_baselines(passed):\n",
    "        if isinstance(passed, dict) and passed:\n",
    "            return passed\n",
    "        try:\n",
    "            return load_baselines()  # if your older helper exists\n",
    "        except Exception:\n",
    "            return _load_sentiment_baselines()\n",
    "\n",
    "    # ---------- 1) Δsentiment from last two 10-Qs ----------\n",
    "    sent_now, sent_prev, d_sent = latest_two_10q_delta_sent(ticker)\n",
    "    # NaN-safe delta for regression\n",
    "    d_sent_safe = float(np.nan_to_num(d_sent if np.isfinite(d_sent) else np.nan, nan=0.0))\n",
    "\n",
    "    # ---------- 2) Market-cap bucket & short-term return prediction ----------\n",
    "    mc   = polygon_market_cap(ticker)\n",
    "    bkt  = cap_bucket(mc)\n",
    "    base = _get_all_baselines(baselines).get(bkt, {})\n",
    "    a7,  b7  = base.get(\"ret7\",{}).get(\"intercept\",0.0),   base.get(\"ret7\",{}).get(\"slope\",0.0)\n",
    "    a28, b28 = base.get(\"ret28\",{}).get(\"intercept\",0.0),  base.get(\"ret28\",{}).get(\"slope\",0.0)\n",
    "    pred7  = a7  + b7  * d_sent_safe\n",
    "    pred28 = a28 + b28 * d_sent_safe\n",
    "\n",
    "    # Auto size w_short if requested\n",
    "    if (w_short is None) or (isinstance(w_short, str) and w_short.lower() == \"auto\"):\n",
    "        w_short = _auto_w_short(bkt, _get_all_baselines(baselines))\n",
    "    w_short = float(w_short)\n",
    "\n",
    "    # ---------- 3) Fundamentals + DCF (static + dynamic) ----------\n",
    "    # Auto-detect sector if not provided\n",
    "    sec_used = sector or detect_sector_polygon(ticker)\n",
    "\n",
    "    cik   = get_cik(ticker)\n",
    "    facts = get_company_facts(cik)\n",
    "    gaap  = build_ttm_metrics(facts)\n",
    "\n",
    "    # Multiples anchor + old static DCF (for reference)\n",
    "    mult        = multiples_anchor(gaap, sector=sec_used)\n",
    "    dcf_static  = dcf_anchor(gaap, years=5, g=0.04, r=0.095, g_term=0.02)\n",
    "\n",
    "    # Dynamic r/g/terminal (your helpers should exist)\n",
    "    r_dyn  = estimate_discount_rate(ticker)                      # consider clamping inside this helper\n",
    "    g_dyn  = estimate_growth_rate(ticker, d_sent_safe)\n",
    "    g_term = estimate_terminal_rate(ticker, sec_used)\n",
    "\n",
    "    ev_raw = raw_dcf_ev(gaap, g_dyn, r_dyn, g_term)              # enterprise value (EV)\n",
    "    sh     = gaap.get(\"diluted_shares_ttm\") or np.nan\n",
    "    dcf_ps = (ev_raw / sh) if (ev_raw is not None and np.isfinite(sh) and sh > 0) else None\n",
    "\n",
    "    # Per-ticker bands (low/mid/high per-share)\n",
    "    vol   = annualized_vol_from_polygon(ticker, lookback_days=252, winsor_pct=0.01) or 0.30\n",
    "    bands = make_dcf_bands(gaap, g_dyn, r_dyn, g_term, vol)\n",
    "\n",
    "    # ---------- 4) Prices + final blend ----------\n",
    "    pnow      = polygon_latest_close(ticker)\n",
    "    price_28d = pnow*(1 + pred28/100.0) if (pnow and np.isfinite(pred28)) else None\n",
    "\n",
    "    # keep the old multiples+static DCF blend as comparison\n",
    "    fair_value_blend_old = blended_fair_value(mult.get(\"fair_value_mid\"), dcf_static, w=0.5)\n",
    "    # new default long-term fair uses multiples mid + dynamic per-share DCF\n",
    "    fair_value_blend = blended_fair_value(mult.get(\"fair_value_mid\"), dcf_ps, w=0.5)\n",
    "\n",
    "    if (price_28d is not None) and (fair_value_blend is not None):\n",
    "        final_target = w_short*price_28d + (1.0 - w_short)*fair_value_blend\n",
    "    else:\n",
    "        final_target = price_28d if price_28d is not None else fair_value_blend\n",
    "\n",
    "    direction = \"UP\" if (final_target is not None and pnow is not None and final_target > pnow) else \"DOWN\"\n",
    "\n",
    "    # ---------- 5) Optional: options vertical suggestion ----------\n",
    "    options_vertical = None\n",
    "    if suggest_spread and pnow and final_target:\n",
    "        try:\n",
    "            options_vertical = best_vertical_by_target(ticker, pnow, final_target)\n",
    "        except Exception as e:\n",
    "            print(f\"[options] skipped for {ticker}: {e}\")\n",
    "\n",
    "    # ---------- 6) Return ----------\n",
    "    return {\n",
    "        \"ticker\": ticker.upper(),\n",
    "        \"sector_used\": sec_used,\n",
    "        \"market_cap\": mc, \"cap_bucket\": bkt,\n",
    "        \"sent_overall_now\": sent_now,\n",
    "        \"sent_overall_prev\": sent_prev,\n",
    "        \"Δsent_overall\": d_sent,             # original key\n",
    "        \"asent_overall\": d_sent_safe,        # NaN-safe alias used by your print cell\n",
    "        \"pred_ret_7d_pct\": pred7,\n",
    "        \"pred_ret_28d_pct\": pred28,\n",
    "        \"price_now\": pnow,\n",
    "        \"price_28d_target\": price_28d,\n",
    "\n",
    "        # Multiples + DCF (keep)\n",
    "        \"multiples_mid\": mult.get(\"fair_value_mid\"),\n",
    "        \"dcf_static\": dcf_static,\n",
    "        \"fair_value_blend_old\": fair_value_blend_old,\n",
    "\n",
    "        # NEW: pure raw-DCF EV/per-share + dynamic rates + bands\n",
    "        \"dcf_ev_raw\": ev_raw,\n",
    "        \"dcf_per_share\": dcf_ps,\n",
    "        \"disc_rate_r\": r_dyn,\n",
    "        \"growth_g\": g_dyn,\n",
    "        \"terminal_g\": g_term,\n",
    "        \"vol_annual\": vol,\n",
    "        \"dcf_bands\": bands,\n",
    "\n",
    "        # Final decision\n",
    "        \"w_short\": w_short,\n",
    "        \"final_blended_target\": final_target,\n",
    "        \"final_direction\": direction,\n",
    "\n",
    "        # Baseline metadata + options (if any)\n",
    "        \"baseline_used\": base,\n",
    "        \"options_vertical\": options_vertical,\n",
    "    }"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2dd55847",
   "metadata": {},
   "source": [
    "### Final Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a2bcd5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def run_full_baseline():\n",
    "    \"\"\"\n",
    "    1. Builds backtest CSV across a mixed-cap universe.\n",
    "    2. Runs legitimacy checks (optional).\n",
    "    3. Fits per-cap baselines and saves to sentiment_baselines.json.\n",
    "    \"\"\"\n",
    "    micro = \"HZO, TIRX, STRC, GWRS, UPXI, GCTK, VTSI, HCAT, OPRX, AOUT, FCEL, HITI, WKSP\".split(\",\")\n",
    "    small = \"BLKB, HQY, PIPR, HAYW, NVCR, SMPL, MGPI, BE, PRCT, SKYW, AVAV, INMD, VRTS, CNXN, REZI, ASTE, MHO, CELH, ABM, PCT\".split(\",\")\n",
    "    mid   = \"LULU, MAR, EA, FSLR, MLM, TTWO, TDY, ENPH, ALB, DAL, CHRW, WDC, AAP, CZR, CHD, SWKS, COHR, PTC, HOLX, MKTX\".split(\",\")\n",
    "    large = \"AAPL, MSFT, AMZN, NVDA, GOOGL, META, JPM, V, JNJ, PG, XOM, UNH, PEP, KO, COST, ORCL, DIS, HD, BAC, WMT\".split(\",\")\n",
    "    TICKERS = [x.strip() for s in (micro+small+mid+large) for x in [s] if x.strip()]\n",
    "    df = backtest_10q_sentiment(TICKERS, max_filings=6)\n",
    "    print(df.head())\n",
    "    _ = run_legitimacy_checks(BACKTEST_CSV)\n",
    "    baselines = fit_bucket_baselines(BACKTEST_CSV)\n",
    "    return baselines\n",
    "\n",
    "def load_sentiment_baselines(path: str = \"10q_sentiment_event_returns.csv\") -> dict:\n",
    "    \"\"\"Read the saved baselines JSON. Fallback: empty dict.\"\"\"\n",
    "    try:\n",
    "        with open(path, \"r\") as f:\n",
    "            return json.load(f)\n",
    "    except Exception:\n",
    "        return {}\n",
    "\n",
    "def run_predict(tickers, w_short=\"auto\", sector=None, suggest_spread=False, baselines=None):\n",
    "    if baselines is None:\n",
    "        baselines = load_sentiment_baselines()   # <-- loader, not fitter\n",
    "    rows = []\n",
    "    for t in tickers:\n",
    "        sec_used = sector or detect_sector_polygon(t)\n",
    "        res = predict_ticker(\n",
    "            t,\n",
    "            w_short=w_short,                     # \"auto\" or float\n",
    "            sector=sec_used,\n",
    "            baselines=baselines,                 # pass once to avoid re-reading JSON per ticker\n",
    "            suggest_spread=suggest_spread\n",
    "        )\n",
    "        res[\"ticker\"] = t\n",
    "        res[\"sector_used\"] = sec_used\n",
    "        rows.append(res)\n",
    "    return pd.DataFrame(rows)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b9dbf216",
   "metadata": {},
   "source": [
    "### Create Baselines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cef60c93",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mKeyboardInterrupt\u001b[39m                         Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[12]\u001b[39m\u001b[32m, line 1\u001b[39m\n\u001b[32m----> \u001b[39m\u001b[32m1\u001b[39m \u001b[43mrun_full_baseline\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[11]\u001b[39m\u001b[32m, line 12\u001b[39m, in \u001b[36mrun_full_baseline\u001b[39m\u001b[34m()\u001b[39m\n\u001b[32m     10\u001b[39m large = \u001b[33m\"\u001b[39m\u001b[33mAAPL, MSFT, AMZN, NVDA, GOOGL, META, JPM, V, JNJ, PG, XOM, UNH, PEP, KO, COST, ORCL, DIS, HD, BAC, WMT\u001b[39m\u001b[33m\"\u001b[39m.split(\u001b[33m\"\u001b[39m\u001b[33m,\u001b[39m\u001b[33m\"\u001b[39m)\n\u001b[32m     11\u001b[39m TICKERS = [x.strip() \u001b[38;5;28;01mfor\u001b[39;00m s \u001b[38;5;129;01min\u001b[39;00m (micro+small+mid+large) \u001b[38;5;28;01mfor\u001b[39;00m x \u001b[38;5;129;01min\u001b[39;00m [s] \u001b[38;5;28;01mif\u001b[39;00m x.strip()]\n\u001b[32m---> \u001b[39m\u001b[32m12\u001b[39m df = \u001b[43mbacktest_10q_sentiment\u001b[49m\u001b[43m(\u001b[49m\u001b[43mTICKERS\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmax_filings\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m6\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m     13\u001b[39m \u001b[38;5;28mprint\u001b[39m(df.head())\n\u001b[32m     14\u001b[39m _ = run_legitimacy_checks(BACKTEST_CSV)\n",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[5]\u001b[39m\u001b[32m, line 2\u001b[39m, in \u001b[36mbacktest_10q_sentiment\u001b[39m\u001b[34m(tickers, max_filings, sleep_sec)\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mbacktest_10q_sentiment\u001b[39m(tickers, max_filings=\u001b[32m6\u001b[39m, sleep_sec=\u001b[32m0.3\u001b[39m):\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m     pipe_tok = \u001b[43mload_finbert\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m      3\u001b[39m     rows = []\n\u001b[32m      4\u001b[39m     \u001b[38;5;28;01mfor\u001b[39;00m t \u001b[38;5;129;01min\u001b[39;00m tickers:\n",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[3]\u001b[39m\u001b[32m, line 3\u001b[39m, in \u001b[36mload_finbert\u001b[39m\u001b[34m()\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34mload_finbert\u001b[39m():\n\u001b[32m      2\u001b[39m     tok = AutoTokenizer.from_pretrained(FINBERT_ID)\n\u001b[32m----> \u001b[39m\u001b[32m3\u001b[39m     mdl = \u001b[43mAutoModelForSequenceClassification\u001b[49m\u001b[43m.\u001b[49m\u001b[43mfrom_pretrained\u001b[49m\u001b[43m(\u001b[49m\u001b[43mFINBERT_ID\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m      4\u001b[39m     pipe = TextClassificationPipeline(model=mdl, tokenizer=tok, top_k=\u001b[38;5;28;01mNone\u001b[39;00m, truncation=\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[32m      5\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m pipe, tok\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/transformers/models/auto/auto_factory.py:604\u001b[39m, in \u001b[36m_BaseAutoModelClass.from_pretrained\u001b[39m\u001b[34m(cls, pretrained_model_name_or_path, *model_args, **kwargs)\u001b[39m\n\u001b[32m    602\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m model_class.config_class == config.sub_configs.get(\u001b[33m\"\u001b[39m\u001b[33mtext_config\u001b[39m\u001b[33m\"\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m):\n\u001b[32m    603\u001b[39m         config = config.get_text_config()\n\u001b[32m--> \u001b[39m\u001b[32m604\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mmodel_class\u001b[49m\u001b[43m.\u001b[49m\u001b[43mfrom_pretrained\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m    605\u001b[39m \u001b[43m        \u001b[49m\u001b[43mpretrained_model_name_or_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43mmodel_args\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mconfig\u001b[49m\u001b[43m=\u001b[49m\u001b[43mconfig\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mhub_kwargs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mkwargs\u001b[49m\n\u001b[32m    606\u001b[39m \u001b[43m    \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    607\u001b[39m \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\n\u001b[32m    608\u001b[39m     \u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mUnrecognized configuration class \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mconfig.\u001b[34m__class__\u001b[39m\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m for this kind of AutoModel: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mcls\u001b[39m.\u001b[34m__name__\u001b[39m\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m.\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[33m\"\u001b[39m\n\u001b[32m    609\u001b[39m     \u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mModel type should be one of \u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[33m'\u001b[39m\u001b[33m, \u001b[39m\u001b[33m'\u001b[39m.join(c.\u001b[34m__name__\u001b[39m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mfor\u001b[39;00m\u001b[38;5;250m \u001b[39mc\u001b[38;5;250m \u001b[39m\u001b[38;5;129;01min\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28mcls\u001b[39m._model_mapping)\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m.\u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    610\u001b[39m )\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/transformers/modeling_utils.py:277\u001b[39m, in \u001b[36mrestore_default_dtype.<locals>._wrapper\u001b[39m\u001b[34m(*args, **kwargs)\u001b[39m\n\u001b[32m    275\u001b[39m old_dtype = torch.get_default_dtype()\n\u001b[32m    276\u001b[39m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m277\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mfunc\u001b[49m\u001b[43m(\u001b[49m\u001b[43m*\u001b[49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    278\u001b[39m \u001b[38;5;28;01mfinally\u001b[39;00m:\n\u001b[32m    279\u001b[39m     torch.set_default_dtype(old_dtype)\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/transformers/modeling_utils.py:5048\u001b[39m, in \u001b[36mPreTrainedModel.from_pretrained\u001b[39m\u001b[34m(cls, pretrained_model_name_or_path, config, cache_dir, ignore_mismatched_sizes, force_download, local_files_only, token, revision, use_safetensors, weights_only, *model_args, **kwargs)\u001b[39m\n\u001b[32m   5038\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m dtype_orig \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[32m   5039\u001b[39m         torch.set_default_dtype(dtype_orig)\n\u001b[32m   5041\u001b[39m     (\n\u001b[32m   5042\u001b[39m         model,\n\u001b[32m   5043\u001b[39m         missing_keys,\n\u001b[32m   5044\u001b[39m         unexpected_keys,\n\u001b[32m   5045\u001b[39m         mismatched_keys,\n\u001b[32m   5046\u001b[39m         offload_index,\n\u001b[32m   5047\u001b[39m         error_msgs,\n\u001b[32m-> \u001b[39m\u001b[32m5048\u001b[39m     ) = \u001b[38;5;28;43mcls\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_load_pretrained_model\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m   5049\u001b[39m \u001b[43m        \u001b[49m\u001b[43mmodel\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5050\u001b[39m \u001b[43m        \u001b[49m\u001b[43mstate_dict\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5051\u001b[39m \u001b[43m        \u001b[49m\u001b[43mcheckpoint_files\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5052\u001b[39m \u001b[43m        \u001b[49m\u001b[43mpretrained_model_name_or_path\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5053\u001b[39m \u001b[43m        \u001b[49m\u001b[43mignore_mismatched_sizes\u001b[49m\u001b[43m=\u001b[49m\u001b[43mignore_mismatched_sizes\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5054\u001b[39m \u001b[43m        \u001b[49m\u001b[43msharded_metadata\u001b[49m\u001b[43m=\u001b[49m\u001b[43msharded_metadata\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5055\u001b[39m \u001b[43m        \u001b[49m\u001b[43mdevice_map\u001b[49m\u001b[43m=\u001b[49m\u001b[43mdevice_map\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5056\u001b[39m \u001b[43m        \u001b[49m\u001b[43mdisk_offload_folder\u001b[49m\u001b[43m=\u001b[49m\u001b[43moffload_folder\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5057\u001b[39m \u001b[43m        \u001b[49m\u001b[43mdtype\u001b[49m\u001b[43m=\u001b[49m\u001b[43mdtype\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5058\u001b[39m \u001b[43m        \u001b[49m\u001b[43mhf_quantizer\u001b[49m\u001b[43m=\u001b[49m\u001b[43mhf_quantizer\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5059\u001b[39m \u001b[43m        \u001b[49m\u001b[43mkeep_in_fp32_regex\u001b[49m\u001b[43m=\u001b[49m\u001b[43mkeep_in_fp32_regex\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5060\u001b[39m \u001b[43m        \u001b[49m\u001b[43mdevice_mesh\u001b[49m\u001b[43m=\u001b[49m\u001b[43mdevice_mesh\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5061\u001b[39m \u001b[43m        \u001b[49m\u001b[43mkey_mapping\u001b[49m\u001b[43m=\u001b[49m\u001b[43mkey_mapping\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5062\u001b[39m \u001b[43m        \u001b[49m\u001b[43mweights_only\u001b[49m\u001b[43m=\u001b[49m\u001b[43mweights_only\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   5063\u001b[39m \u001b[43m    \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   5064\u001b[39m \u001b[38;5;66;03m# make sure token embedding weights are still tied if needed\u001b[39;00m\n\u001b[32m   5065\u001b[39m model.tie_weights()\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/transformers/modeling_utils.py:5316\u001b[39m, in \u001b[36mPreTrainedModel._load_pretrained_model\u001b[39m\u001b[34m(cls, model, state_dict, checkpoint_files, pretrained_model_name_or_path, ignore_mismatched_sizes, sharded_metadata, device_map, disk_offload_folder, dtype, hf_quantizer, keep_in_fp32_regex, device_mesh, key_mapping, weights_only)\u001b[39m\n\u001b[32m   5313\u001b[39m     original_checkpoint_keys = \u001b[38;5;28mlist\u001b[39m(state_dict.keys())\n\u001b[32m   5314\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m   5315\u001b[39m     original_checkpoint_keys = \u001b[38;5;28mlist\u001b[39m(\n\u001b[32m-> \u001b[39m\u001b[32m5316\u001b[39m         \u001b[43mload_state_dict\u001b[49m\u001b[43m(\u001b[49m\u001b[43mcheckpoint_files\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmap_location\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mmeta\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mweights_only\u001b[49m\u001b[43m=\u001b[49m\u001b[43mweights_only\u001b[49m\u001b[43m)\u001b[49m.keys()\n\u001b[32m   5317\u001b[39m     )\n\u001b[32m   5319\u001b[39m \u001b[38;5;66;03m# Check if we are in a special state, i.e. loading from a state dict coming from a different architecture\u001b[39;00m\n\u001b[32m   5320\u001b[39m prefix = model.base_model_prefix\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/transformers/modeling_utils.py:526\u001b[39m, in \u001b[36mload_state_dict\u001b[39m\u001b[34m(checkpoint_file, is_quantized, map_location, weights_only)\u001b[39m\n\u001b[32m    524\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(checkpoint_file, \u001b[38;5;28mstr\u001b[39m) \u001b[38;5;129;01mand\u001b[39;00m map_location != \u001b[33m\"\u001b[39m\u001b[33mmeta\u001b[39m\u001b[33m\"\u001b[39m \u001b[38;5;129;01mand\u001b[39;00m is_zipfile(checkpoint_file):\n\u001b[32m    525\u001b[39m         extra_args = {\u001b[33m\"\u001b[39m\u001b[33mmmap\u001b[39m\u001b[33m\"\u001b[39m: \u001b[38;5;28;01mTrue\u001b[39;00m}\n\u001b[32m--> \u001b[39m\u001b[32m526\u001b[39m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mtorch\u001b[49m\u001b[43m.\u001b[49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m    527\u001b[39m \u001b[43m        \u001b[49m\u001b[43mcheckpoint_file\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    528\u001b[39m \u001b[43m        \u001b[49m\u001b[43mmap_location\u001b[49m\u001b[43m=\u001b[49m\u001b[43mmap_location\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    529\u001b[39m \u001b[43m        \u001b[49m\u001b[43mweights_only\u001b[49m\u001b[43m=\u001b[49m\u001b[43mweights_only\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    530\u001b[39m \u001b[43m        \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mextra_args\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m    531\u001b[39m \u001b[43m    \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    532\u001b[39m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mException\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[32m    533\u001b[39m     \u001b[38;5;28;01mtry\u001b[39;00m:\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/torch/serialization.py:1521\u001b[39m, in \u001b[36mload\u001b[39m\u001b[34m(f, map_location, pickle_module, weights_only, mmap, **pickle_load_args)\u001b[39m\n\u001b[32m   1519\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m weights_only:\n\u001b[32m   1520\u001b[39m     \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[32m-> \u001b[39m\u001b[32m1521\u001b[39m         \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_load\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m   1522\u001b[39m \u001b[43m            \u001b[49m\u001b[43mopened_zipfile\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   1523\u001b[39m \u001b[43m            \u001b[49m\u001b[43mmap_location\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   1524\u001b[39m \u001b[43m            \u001b[49m\u001b[43m_weights_only_unpickler\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   1525\u001b[39m \u001b[43m            \u001b[49m\u001b[43moverall_storage\u001b[49m\u001b[43m=\u001b[49m\u001b[43moverall_storage\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   1526\u001b[39m \u001b[43m            \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mpickle_load_args\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m   1527\u001b[39m \u001b[43m        \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   1528\u001b[39m     \u001b[38;5;28;01mexcept\u001b[39;00m pickle.UnpicklingError \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[32m   1529\u001b[39m         \u001b[38;5;28;01mraise\u001b[39;00m pickle.UnpicklingError(_get_wo_message(\u001b[38;5;28mstr\u001b[39m(e))) \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mNone\u001b[39;00m\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/torch/serialization.py:2122\u001b[39m, in \u001b[36m_load\u001b[39m\u001b[34m(zip_file, map_location, pickle_module, pickle_file, overall_storage, **pickle_load_args)\u001b[39m\n\u001b[32m   2120\u001b[39m \u001b[38;5;28;01mglobal\u001b[39;00m _serialization_tls\n\u001b[32m   2121\u001b[39m _serialization_tls.map_location = map_location\n\u001b[32m-> \u001b[39m\u001b[32m2122\u001b[39m result = \u001b[43munpickler\u001b[49m\u001b[43m.\u001b[49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2123\u001b[39m _serialization_tls.map_location = \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[32m   2125\u001b[39m torch._utils._validate_loaded_sparse_tensors()\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/torch/_weights_only_unpickler.py:535\u001b[39m, in \u001b[36mUnpickler.load\u001b[39m\u001b[34m(self)\u001b[39m\n\u001b[32m    527\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m (\n\u001b[32m    528\u001b[39m         \u001b[38;5;28mtype\u001b[39m(pid) \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28mtuple\u001b[39m\n\u001b[32m    529\u001b[39m         \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mlen\u001b[39m(pid) > \u001b[32m0\u001b[39m\n\u001b[32m    530\u001b[39m         \u001b[38;5;129;01mand\u001b[39;00m torch.serialization._maybe_decode_ascii(pid[\u001b[32m0\u001b[39m]) != \u001b[33m\"\u001b[39m\u001b[33mstorage\u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m    531\u001b[39m     ):\n\u001b[32m    532\u001b[39m         \u001b[38;5;28;01mraise\u001b[39;00m UnpicklingError(\n\u001b[32m    533\u001b[39m             \u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mOnly persistent_load of storage is allowed, but got \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mpid[\u001b[32m0\u001b[39m]\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m\n\u001b[32m    534\u001b[39m         )\n\u001b[32m--> \u001b[39m\u001b[32m535\u001b[39m     \u001b[38;5;28mself\u001b[39m.append(\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mpersistent_load\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpid\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[32m    536\u001b[39m \u001b[38;5;28;01melif\u001b[39;00m key[\u001b[32m0\u001b[39m] \u001b[38;5;129;01min\u001b[39;00m [BINGET[\u001b[32m0\u001b[39m], LONG_BINGET[\u001b[32m0\u001b[39m]]:\n\u001b[32m    537\u001b[39m     idx = (read(\u001b[32m1\u001b[39m) \u001b[38;5;28;01mif\u001b[39;00m key[\u001b[32m0\u001b[39m] == BINGET[\u001b[32m0\u001b[39m] \u001b[38;5;28;01melse\u001b[39;00m unpack(\u001b[33m\"\u001b[39m\u001b[33m<I\u001b[39m\u001b[33m\"\u001b[39m, read(\u001b[32m4\u001b[39m)))[\u001b[32m0\u001b[39m]\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/torch/serialization.py:2086\u001b[39m, in \u001b[36m_load.<locals>.persistent_load\u001b[39m\u001b[34m(saved_id)\u001b[39m\n\u001b[32m   2084\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m   2085\u001b[39m     nbytes = numel * torch._utils._element_size(dtype)\n\u001b[32m-> \u001b[39m\u001b[32m2086\u001b[39m     typed_storage = \u001b[43mload_tensor\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m   2087\u001b[39m \u001b[43m        \u001b[49m\u001b[43mdtype\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnbytes\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mkey\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m_maybe_decode_ascii\u001b[49m\u001b[43m(\u001b[49m\u001b[43mlocation\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2088\u001b[39m \u001b[43m    \u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2090\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m typed_storage\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/Desktop/project-fa25-QVP/venv/lib/python3.13/site-packages/torch/serialization.py:2039\u001b[39m, in \u001b[36m_load.<locals>.load_tensor\u001b[39m\u001b[34m(dtype, numel, key, location)\u001b[39m\n\u001b[32m   2032\u001b[39m         \u001b[38;5;28;01mif\u001b[39;00m storage_offset != zip_file.get_record_offset(name):\n\u001b[32m   2033\u001b[39m             \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mRuntimeError\u001b[39;00m(\n\u001b[32m   2034\u001b[39m                 \u001b[33m\"\u001b[39m\u001b[33mThis is a debug assert that was run as the `TORCH_SERIALIZATION_DEBUG` environment \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m   2035\u001b[39m                 \u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mvariable was set: Incorrect offset for \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mname\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m, got \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mstorage_offset\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m expected \u001b[39m\u001b[33m\"\u001b[39m\n\u001b[32m   2036\u001b[39m                 \u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mzip_file.get_record_offset(name)\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m\n\u001b[32m   2037\u001b[39m             )\n\u001b[32m   2038\u001b[39m     storage = (\n\u001b[32m-> \u001b[39m\u001b[32m2039\u001b[39m         \u001b[43mzip_file\u001b[49m\u001b[43m.\u001b[49m\u001b[43mget_storage_from_record\u001b[49m\u001b[43m(\u001b[49m\u001b[43mname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnumel\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtorch\u001b[49m\u001b[43m.\u001b[49m\u001b[43mUntypedStorage\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2040\u001b[39m         ._typed_storage()\n\u001b[32m   2041\u001b[39m         ._untyped_storage\n\u001b[32m   2042\u001b[39m     )\n\u001b[32m   2043\u001b[39m \u001b[38;5;66;03m# swap here if byteswapping is needed\u001b[39;00m\n\u001b[32m   2044\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m byteorderdata \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
      "\u001b[31mKeyboardInterrupt\u001b[39m: "
     ]
    }
   ],
   "source": [
    "baselines = run_full_baseline()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a6b72688",
   "metadata": {},
   "source": [
    "### Analyze Baselines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "262b339f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 700x500 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>ticker</th>\n",
       "      <th>filing_date</th>\n",
       "      <th>Δsent_overall</th>\n",
       "      <th>ret_28</th>\n",
       "      <th>ret_28_w</th>\n",
       "      <th>_resid</th>\n",
       "      <th>resid_abs</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>54</th>\n",
       "      <td>FCEL</td>\n",
       "      <td>2025-09-09</td>\n",
       "      <td>-0.032653</td>\n",
       "      <td>96.718147</td>\n",
       "      <td>62.467654</td>\n",
       "      <td>70.852132</td>\n",
       "      <td>70.852132</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>27</th>\n",
       "      <td>GCTK</td>\n",
       "      <td>2024-08-13</td>\n",
       "      <td>0.140295</td>\n",
       "      <td>91.980393</td>\n",
       "      <td>62.467654</td>\n",
       "      <td>52.325015</td>\n",
       "      <td>52.325015</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>31</th>\n",
       "      <td>VTSI</td>\n",
       "      <td>2025-05-12</td>\n",
       "      <td>0.000000</td>\n",
       "      <td>43.683084</td>\n",
       "      <td>43.683084</td>\n",
       "      <td>48.569552</td>\n",
       "      <td>48.569552</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>50</th>\n",
       "      <td>AOUT</td>\n",
       "      <td>2024-12-05</td>\n",
       "      <td>-0.001177</td>\n",
       "      <td>37.889908</td>\n",
       "      <td>37.889908</td>\n",
       "      <td>42.902477</td>\n",
       "      <td>42.902477</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>21</th>\n",
       "      <td>UPXI</td>\n",
       "      <td>2024-07-09</td>\n",
       "      <td>0.034760</td>\n",
       "      <td>-38.733658</td>\n",
       "      <td>-37.695455</td>\n",
       "      <td>-36.532644</td>\n",
       "      <td>36.532644</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>22</th>\n",
       "      <td>UPXI</td>\n",
       "      <td>2024-02-14</td>\n",
       "      <td>0.008489</td>\n",
       "      <td>-61.413043</td>\n",
       "      <td>-37.695455</td>\n",
       "      <td>-33.718390</td>\n",
       "      <td>33.718390</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>56</th>\n",
       "      <td>FCEL</td>\n",
       "      <td>2025-03-11</td>\n",
       "      <td>0.007627</td>\n",
       "      <td>-40.320122</td>\n",
       "      <td>-37.695455</td>\n",
       "      <td>-33.626049</td>\n",
       "      <td>33.626049</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>34</th>\n",
       "      <td>VTSI</td>\n",
       "      <td>2024-05-14</td>\n",
       "      <td>0.000000</td>\n",
       "      <td>-50.578915</td>\n",
       "      <td>-37.695455</td>\n",
       "      <td>-32.808986</td>\n",
       "      <td>32.808986</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   ticker filing_date  Δsent_overall     ret_28   ret_28_w     _resid  \\\n",
       "54   FCEL  2025-09-09      -0.032653  96.718147  62.467654  70.852132   \n",
       "27   GCTK  2024-08-13       0.140295  91.980393  62.467654  52.325015   \n",
       "31   VTSI  2025-05-12       0.000000  43.683084  43.683084  48.569552   \n",
       "50   AOUT  2024-12-05      -0.001177  37.889908  37.889908  42.902477   \n",
       "21   UPXI  2024-07-09       0.034760 -38.733658 -37.695455 -36.532644   \n",
       "22   UPXI  2024-02-14       0.008489 -61.413043 -37.695455 -33.718390   \n",
       "56   FCEL  2025-03-11       0.007627 -40.320122 -37.695455 -33.626049   \n",
       "34   VTSI  2024-05-14       0.000000 -50.578915 -37.695455 -32.808986   \n",
       "\n",
       "    resid_abs  \n",
       "54  70.852132  \n",
       "27  52.325015  \n",
       "31  48.569552  \n",
       "50  42.902477  \n",
       "21  36.532644  \n",
       "22  33.718390  \n",
       "56  33.626049  \n",
       "34  32.808986  "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 700x500 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>ticker</th>\n",
       "      <th>filing_date</th>\n",
       "      <th>Δsent_overall</th>\n",
       "      <th>ret_28</th>\n",
       "      <th>ret_28_w</th>\n",
       "      <th>_resid</th>\n",
       "      <th>resid_abs</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>94</th>\n",
       "      <td>NVCR</td>\n",
       "      <td>2024-05-02</td>\n",
       "      <td>0.000002</td>\n",
       "      <td>56.941508</td>\n",
       "      <td>56.941508</td>\n",
       "      <td>54.172217</td>\n",
       "      <td>54.172217</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>HZO</td>\n",
       "      <td>2024-07-25</td>\n",
       "      <td>-0.026818</td>\n",
       "      <td>-19.083558</td>\n",
       "      <td>-19.083558</td>\n",
       "      <td>-24.270366</td>\n",
       "      <td>24.270366</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>43</th>\n",
       "      <td>OPRX</td>\n",
       "      <td>2025-05-13</td>\n",
       "      <td>-0.204029</td>\n",
       "      <td>40.236149</td>\n",
       "      <td>40.236149</td>\n",
       "      <td>19.075727</td>\n",
       "      <td>19.075727</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>46</th>\n",
       "      <td>OPRX</td>\n",
       "      <td>2024-05-15</td>\n",
       "      <td>-0.031948</td>\n",
       "      <td>-11.161731</td>\n",
       "      <td>-11.161731</td>\n",
       "      <td>-16.810889</td>\n",
       "      <td>16.810889</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>HZO</td>\n",
       "      <td>2025-04-24</td>\n",
       "      <td>-0.084028</td>\n",
       "      <td>-5.116895</td>\n",
       "      <td>-5.116895</td>\n",
       "      <td>-15.460490</td>\n",
       "      <td>15.460490</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>150</th>\n",
       "      <td>ASTE</td>\n",
       "      <td>2025-08-06</td>\n",
       "      <td>0.011798</td>\n",
       "      <td>16.124937</td>\n",
       "      <td>16.124937</td>\n",
       "      <td>14.418933</td>\n",
       "      <td>14.418933</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>93</th>\n",
       "      <td>NVCR</td>\n",
       "      <td>2024-07-25</td>\n",
       "      <td>-0.018424</td>\n",
       "      <td>-8.900804</td>\n",
       "      <td>-8.900804</td>\n",
       "      <td>-13.330947</td>\n",
       "      <td>13.330947</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>44</th>\n",
       "      <td>OPRX</td>\n",
       "      <td>2024-11-14</td>\n",
       "      <td>-0.059721</td>\n",
       "      <td>21.428571</td>\n",
       "      <td>21.428571</td>\n",
       "      <td>13.275966</td>\n",
       "      <td>13.275966</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    ticker filing_date  Δsent_overall     ret_28   ret_28_w     _resid  \\\n",
       "94    NVCR  2024-05-02       0.000002  56.941508  56.941508  54.172217   \n",
       "3      HZO  2024-07-25      -0.026818 -19.083558 -19.083558 -24.270366   \n",
       "43    OPRX  2025-05-13      -0.204029  40.236149  40.236149  19.075727   \n",
       "46    OPRX  2024-05-15      -0.031948 -11.161731 -11.161731 -16.810889   \n",
       "1      HZO  2025-04-24      -0.084028  -5.116895  -5.116895 -15.460490   \n",
       "150   ASTE  2025-08-06       0.011798  16.124937  16.124937  14.418933   \n",
       "93    NVCR  2024-07-25      -0.018424  -8.900804  -8.900804 -13.330947   \n",
       "44    OPRX  2024-11-14      -0.059721  21.428571  21.428571  13.275966   \n",
       "\n",
       "     resid_abs  \n",
       "94   54.172217  \n",
       "3    24.270366  \n",
       "43   19.075727  \n",
       "46   16.810889  \n",
       "1    15.460490  \n",
       "150  14.418933  \n",
       "93   13.330947  \n",
       "44   13.275966  "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# === Visual check for micro/small buckets: scatter + baseline line + outlier labels ===\n",
    "import json, math, matplotlib.pyplot as plt\n",
    "\n",
    "HORIZON = \"ret_28\"   # change to \"ret_7\" if you want 7-day\n",
    "CSV_PATH = BACKTEST_CSV\n",
    "BASE_JSON = BASELINES_JSON\n",
    "\n",
    "def _winsorize(s, p=0.01):\n",
    "    lo, hi = s.quantile(p), s.quantile(1-p)\n",
    "    return s.clip(lo, hi)\n",
    "\n",
    "# 1) Load backtest rows and rebuild Δsent_overall\n",
    "df = pd.read_csv(CSV_PATH)\n",
    "df[\"filing_date\"] = pd.to_datetime(df[\"filing_date\"])\n",
    "df = df.sort_values([\"ticker\",\"filing_date\"])\n",
    "df[\"Δsent_overall\"] = df.groupby(\"ticker\")[\"sent_overall\"].diff()\n",
    "\n",
    "# 2) Attach market caps + buckets (light Polygon calls; NOT re-scraping filings)\n",
    "#    (Reuses your polygon_market_cap + cap_bucket helpers defined earlier)\n",
    "mc_map = {t: polygon_market_cap(t) for t in df[\"ticker\"].unique()}\n",
    "df[\"market_cap\"] = df[\"ticker\"].map(mc_map)\n",
    "df[\"bucket\"] = df[\"market_cap\"].map(cap_bucket)\n",
    "\n",
    "# 3) Pick bucket subset(s) and winsorize returns to reduce distortion\n",
    "use = df.dropna(subset=[\"Δsent_overall\", HORIZON]).copy()\n",
    "use[HORIZON+\"_w\"] = _winsorize(use[HORIZON], p=0.01)\n",
    "\n",
    "# 4) Load saved baselines (so we can plot the learned line on top)\n",
    "with open(BASE_JSON, \"r\") as f:\n",
    "    base = json.load(f)\n",
    "\n",
    "def _plot_bucket(bucket_name):\n",
    "    d = use[use[\"bucket\"] == bucket_name].dropna(subset=[\"Δsent_overall\", HORIZON+\"_w\"]).copy()\n",
    "    if d.empty:\n",
    "        print(f\"[info] No rows for bucket={bucket_name}\")\n",
    "        return\n",
    "\n",
    "    # OLS on this subset\n",
    "    X = np.c_[np.ones(len(d)), d[\"Δsent_overall\"].values]\n",
    "    y = d[HORIZON+\"_w\"].values\n",
    "    beta = np.linalg.pinv(X).dot(y)\n",
    "    a_hat, b_hat = float(beta[0]), float(beta[1])\n",
    "\n",
    "    # Residuals as a Series aligned to d's index\n",
    "    y_hat = a_hat + b_hat * d[\"Δsent_overall\"].values\n",
    "    resid = pd.Series(y - y_hat, index=d.index, name=\"_resid\")\n",
    "\n",
    "    # Top outliers by |resid|\n",
    "    out_idx = resid.abs().sort_values(ascending=False).head(8).index\n",
    "    out = d.loc[out_idx].copy()\n",
    "    out[\"_resid\"] = resid.loc[out_idx]\n",
    "\n",
    "    # Saved baseline line\n",
    "    saved = base.get(bucket_name, {}).get(\"ret28\" if HORIZON == \"ret_28\" else \"ret7\", {})\n",
    "    a0 = saved.get(\"intercept\", np.nan)\n",
    "    b0 = saved.get(\"slope\", np.nan)\n",
    "    n0 = saved.get(\"n\", 0)\n",
    "\n",
    "    # Plot\n",
    "    plt.figure(figsize=(7, 5))\n",
    "    plt.scatter(d[\"Δsent_overall\"], d[HORIZON+\"_w\"], s=25, alpha=0.65)\n",
    "    xs = np.linspace(d[\"Δsent_overall\"].min(), d[\"Δsent_overall\"].max(), 200)\n",
    "\n",
    "    # This-subset OLS fit\n",
    "    plt.plot(xs, a_hat + b_hat * xs, linewidth=2, label=f\"OLS subset: a={a_hat:.2f}, b={b_hat:.2f}\")\n",
    "\n",
    "    # Saved baseline fit (if available)\n",
    "    if np.isfinite(a0) and np.isfinite(b0):\n",
    "        plt.plot(xs, a0 + b0 * xs, linestyle=\"--\", linewidth=2,\n",
    "                 label=f\"Saved baseline: a={a0:.2f}, b={b0:.2f}, n={n0}\")\n",
    "\n",
    "    plt.title(f\"{bucket_name.upper()} — Δsent_overall vs {HORIZON} (winsorized)\")\n",
    "    plt.xlabel(\"Δsent_overall\")\n",
    "    plt.ylabel(f\"{HORIZON} return (%)\")\n",
    "    plt.grid(True, alpha=0.25)\n",
    "    plt.legend(loc=\"best\")\n",
    "\n",
    "    # Annotate top outliers\n",
    "    for _, r in out.iterrows():\n",
    "        plt.annotate(r[\"ticker\"], (r[\"Δsent_overall\"], r[HORIZON+\"_w\"]),\n",
    "                     xytext=(5, 5), textcoords=\"offset points\", fontsize=8)\n",
    "\n",
    "    plt.show()\n",
    "\n",
    "    # Table of those outliers\n",
    "    display(\n",
    "        out[[\"ticker\", \"filing_date\", \"Δsent_overall\", HORIZON, HORIZON+\"_w\", \"_resid\"]]\n",
    "        .assign(resid_abs=lambda x: x[\"_resid\"].abs())\n",
    "        .sort_values(\"resid_abs\", ascending=False)\n",
    "    )\n",
    "\n",
    "# 5) Generate plots for micro and small\n",
    "_plot_bucket(\"micro\")\n",
    "_plot_bucket(\"small\")\n",
    "_plot_bucket(\"mid\")\n",
    "_plot_bucket(\"large\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f270d12e",
   "metadata": {},
   "source": [
    "### Run Predictions on Given Ticker"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f96f903",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Device set to use cpu\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[warn] EPS*Shares != NetIncome by >15%. Check tags/periods.\n",
      "[Tradier] JSON error (expirations) for LEG: Expecting value: line 1 column 1 (char 0)\n",
      "<!DOCTYPE html><html lang=\"en\" style=\"\" data-color-mode=\"system\" class=\" useReactApp  \"><head><meta charset=\"utf-8\"><meta name=\"readme-deploy\" content=\"5.512.0\"><meta name=\"readme-subdomain\" content=\"tradier\"><meta name=\"readme-repo\" content=\"tradier-8c8bc2921262\"><meta name=\"readme-version\" content=\"1.0\"><title>Tradier API</title><meta name=\"description\" data-rh=\"true\"><meta property=\"og:title\" c\n",
      "=== Prediction Summary ===\n",
      "Ticker: LEG\n",
      "Cap bucket: small | Market cap: 1,242,521,895.42\n",
      "Asent_overall: nan\n",
      "Pred 7d: 1.81% | Pred 28d: 1.56%\n",
      "Price now: 10.59\n",
      "DCF (static) fair value: 10.95\n",
      "Multiples mid: 33.99\n",
      "28d target: 10.75\n",
      "DCF bands — Low: 4.40 | Mid: 5.27 | High: 6.51\n",
      "r: 16.50% | g: 1.80% | g_term: 2.50% | vol_ann: 44.16%\n",
      "Final blended target: 16.97  ->  UP\n",
      "\n",
      "(No options suggestion — ensure TRADIER_ACCESS_TOKEN is set and chains are available.)\n",
      "\n",
      "(No options suggestion – ensure TRADIER_ACCESS_TOKEN is set and chains are available.)\n"
     ]
    }
   ],
   "source": [
    "# Assuming you already ran the cells that define run_predict() etc.\n",
    "ticker = \"LEG\"  # <-- set your ticker symbol\n",
    "\n",
    "pred = run_predict([\"LEG\"], w_short=\"auto\", suggest_spread=False).iloc[0].to_dict()\n",
    "print(\"sector:\", pred[\"sector_used\"], \"| cap bucket:\", pred[\"cap_bucket\"], \"| w_short:\", pred[\"w_short\"])\n",
    "\n",
    "def print_valuation_summary(pred: dict):\n",
    "    print(\"=== Prediction Summary ===\")\n",
    "    print(f\"Ticker: {pred.get('ticker', '—')}\")\n",
    "    print(f\"Cap bucket: {pred.get('cap_bucket', '—')} | Market cap: {pred.get('market_cap', '—'):,}\")\n",
    "    print(f\"Asent_overall: {pred.get('asent_overall', float('nan')):.4f}\")\n",
    "    print(f\"Pred 7d: {pred.get('pred_ret_7d_pct', float('nan')):.2f}% | Pred 28d: {pred.get('pred_ret_28d_pct', float('nan')):.2f}%\")\n",
    "    print(f\"Price now: {pred.get('price_now', float('nan')):.2f}\")\n",
    "\n",
    "    # renamed keys here:\n",
    "    if 'dcf_static' in pred:\n",
    "        print(f\"DCF (static) fair value: {pred['dcf_static']:.2f}\")\n",
    "    if 'multiples_mid' in pred:\n",
    "        print(f\"Multiples mid: {pred['multiples_mid']:.2f}\")\n",
    "    if 'price_28d_target' in pred:\n",
    "        print(f\"28d target: {pred['price_28d_target']:.2f}\")\n",
    "\n",
    "    # dynamic DCF diagnostics (new fields)\n",
    "    if 'dcf_bands' in pred:\n",
    "        b = pred['dcf_bands']\n",
    "        print(f\"DCF bands — Low: {b.get('low','—'):.2f} | Mid: {b.get('mid','—'):.2f} | High: {b.get('high','—'):.2f}\")\n",
    "    if 'disc_rate_r' in pred:\n",
    "        print(f\"r: {pred['disc_rate_r']:.2%} | g: {pred.get('growth_g', float('nan')):.2%} | g_term: {pred.get('terminal_g', float('nan')):.2%} | vol_ann: {pred.get('vol_annual', float('nan')):.2%}\")\n",
    "\n",
    "    # final blend\n",
    "    if 'final_blended_target' in pred:\n",
    "        print(f\"Final blended target: {pred['final_blended_target']:.2f}, {pred.get('final_direction','—')}\")\n",
    "\n",
    "    # optional options suggestion\n",
    "    ov = pred.get(\"options_vertical\")\n",
    "    if ov:\n",
    "        print(\"\\n== Suggested Options Vertical ==\")\n",
    "        print(f\"Type: {ov.get('type','—')}  |  Exp: {ov.get('expiration','—')}\")\n",
    "        print(f\"Buy: {ov.get('buy_strike','—')}  |  Sell: {ov.get('sell_strike','—')}\")\n",
    "        print(f\"Debit: {ov.get('debit','—')}  |  Width: {ov.get('width','—')}  |  Max Profit: {ov.get('max_profit','—')}\")\n",
    "        print(f\"R:R (profit/risk): {ov.get('R_by_Risk','—')}\")\n",
    "    else:\n",
    "        print(\"\\n(No options suggestion — ensure TRADIER_ACCESS_TOKEN is set and chains are available.)\")\n",
    "\n",
    "# call it\n",
    "print_valuation_summary(pred)\n",
    "\n",
    "ov = pred.get(\"options_vertical\")\n",
    "if ov:\n",
    "    print(\"\\n=== Suggested Options Vertical ===\")\n",
    "    print(f\"Type: {ov['type']}  |  Exp: {ov['expiration']}\")\n",
    "    print(f\"Buy {ov['buy_strike']}  /  Sell {ov['sell_strike']}\")\n",
    "    print(f\"Debit: {ov['debit']}  |  Width: {ov['width']}  |  Max Profit: {ov['max_profit']}\")\n",
    "    print(f\"R:R (profit/risk): {ov['R_by_Risk']}\")\n",
    "else:\n",
    "    print(\"\\n(No options suggestion – ensure TRADIER_ACCESS_TOKEN is set and chains are available.)\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
